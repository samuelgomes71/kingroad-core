data class RegionalGradeLimits(
    val country: String,
    val region: String? = null,
    val maxGradeThreshold: Double,
    val description: String
)

class RegionalRouteSafetyAnalyzer(
    private val defaultConfig: SafetyConfig = SafetyConfig()
) {
    data class SafetyConfig(
        val defaultMaxGrade: Double = 10.0,      // Padr√£o global
        val sharpTurnThreshold: Double = 90.0,   // √Çngulo para curva fechada
        val hairpinThreshold: Double = 150.0,    // √Çngulo para cotovelo
        val segmentLength: Double = 50.0         // Comprimento do segmento para an√°lise
    )

    // Lista de exce√ß√µes regionais
    private val regionalLimits = listOf(
        RegionalGradeLimits(
            country = "CH",                  // Su√≠√ßa
            maxGradeThreshold = 12.0,
            description = "Swiss Alpine Roads"
        ),
        RegionalGradeLimits(
            country = "CA",                  // Canad√°
            region = "QC",                   // Quebec
            maxGradeThreshold = 14.0,
            description = "Quebec Mountain Routes"
        ),
        RegionalGradeLimits(
            country = "CA",                  // Outras regi√µes do Canad√°
            maxGradeThreshold = 11.0,
            description = "Canadian Routes"
        )
    )

    fun getRegionalGradeLimit(country: String, region: String? = null): Double {
        // Primeiro tenta encontrar limite espec√≠fico para regi√£o
        val regionLimit = regionalLimits.find { 
            it.country == country && it.region == region 
        }
        
        // Se n√£o encontrar, procura limite do pa√≠s
        val countryLimit = regionalLimits.find { 
            it.country == country && it.region == null 
        }
        
        // Retorna o limite encontrado ou o padr√£o
        return regionLimit?.maxGradeThreshold 
            ?: countryLimit?.maxGradeThreshold 
            ?: defaultConfig.defaultMaxGrade
    }

    fun analyzeRouteSegment(
        segment: RouteSegment,
        country: String,
        region: String? = null
    ): List<RouteHazard> {
        val hazards = mutableListOf<RouteHazard>()
        val maxGrade = getRegionalGradeLimit(country, region)

        // Verifica inclina√ß√£o considerando limite regional
        val grade = segment.grade
        when {
            grade > maxGrade -> {
                hazards.add(RouteHazard(
                    type = HazardType.STEEP_ASCENT,
                    location = segment.startPoint,
                    severity = (grade / maxGrade) * 100,
                    description = buildGradeDescription(grade, maxGrade, true)
                ))
            }
            grade < -maxGrade -> {
                hazards.add(RouteHazard(
                    type = HazardType.STEEP_DESCENT,
                    location = segment.startPoint,
                    severity = (Math.abs(grade) / maxGrade) * 100,
                    description = buildGradeDescription(Math.abs(grade), maxGrade, false)
                ))
            }
        }

        // Analisa curvas independente da regi√£o
        segment.turnAngle?.let { angle ->
            when {
                angle > defaultConfig.hairpinThreshold -> {
                    hazards.add(RouteHazard(
                        type = HazardType.HAIRPIN_TURN,
                        location = segment.startPoint,
                        severity = (angle / defaultConfig.hairpinThreshold) * 100,
                        description = "Curva cotovelo de ${angle.toInt()}¬∞"
                    ))
                }
                angle > defaultConfig.sharpTurnThreshold -> {
                    hazards.add(RouteHazard(
                        type = HazardType.SHARP_TURN,
                        location = segment.startPoint,
                        severity = (angle / defaultConfig.sharpTurnThreshold) * 100,
                        description = "Curva fechada de ${angle.toInt()}¬∞"
                    ))
                }
            }
        }

        return hazards
    }

    private fun buildGradeDescription(
        grade: Double, 
        limit: Double,
        isAscent: Boolean
    ): String {
        val direction = if (isAscent) "Subida" else "Descida"
        val gradeStr = grade.toInt()
        val limitStr = limit.toInt()
        
        return when {
            grade > limit * 1.2 -> "$direction muito √≠ngreme de $gradeStr% (limite local: $limitStr%)"
            else -> "$direction √≠ngreme de $gradeStr% (limite local: $limitStr%)"
        }
    }

    fun generateWarningMessage(hazards: List<RouteHazard>, country: String, region: String?): String {
        val limit = getRegionalGradeLimit(country, region)
        
        return buildString {
            appendLine("‚ö†Ô∏è ATEN√á√ÉO: Esta rota possui trechos desafiadores:")
            appendLine()
            appendLine("Limite de inclina√ß√£o local: $limit%")
            appendLine()
            
            hazards.groupBy { it.type }.forEach { (type, typeHazards) ->
                val count = typeHazards.size
                when (type) {
                    HazardType.STEEP_ASCENT -> {
                        appendLine("üî∫ $count ${if (count > 1) "subidas √≠ngremes" else "subida √≠ngreme"}")
                        typeHazards.forEach { appendLine("   - ${it.description}") }
                    }
                    HazardType.STEEP_DESCENT -> {
                        appendLine("üîª $count ${if (count > 1) "descidas √≠ngremes" else "descida √≠ngreme"}")
                        typeHazards.forEach { appendLine("   - ${it.description}") }
                    }
                    HazardType.HAIRPIN_TURN -> {
                        appendLine("‚Ü©Ô∏è $count ${if (count > 1) "curvas cotovelo" else "curva cotovelo"}")
                        typeHazards.forEach { appendLine("   - ${it.description}") }
                    }
                    HazardType.SHARP_TURN -> {
                        appendLine("‚Ü™Ô∏è $count ${if (count > 1) "curvas fechadas" else "curva fechada"}")
                        typeHazards.forEach { appendLine("   - ${it.description}") }
                    }
                }
                appendLine()
            }
        }
    }
}