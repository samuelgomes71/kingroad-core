// Sistema de Gerenciamento de Mapas Offline
// app/src/main/kotlin/com/kingroad/maps/offline

class OfflineMapManager(
    private val storageManager: StorageManager,
    private val mapService: MapService,
    private val networkManager: NetworkManager,
    private val preferencesManager: PreferencesManager
) {
    data class MapRegion(
        val id: String,
        val name: String,
        val country: Country,
        val boundingBox: BoundingBox,
        val size: Long,          // tamanho em bytes
        val lastUpdate: Long,    // timestamp
        val type: MapType,
        val subRegions: List<MapRegion>? = null
    )

    data class Country(
        val code: String,        // ISO code
        val name: String,
        val continent: Continent,
        val availableTypes: List<MapType>,
        val totalSize: Long,     // tamanho total em bytes
        val lastUpdate: Long     // timestamp
    )

    enum class MapType {
        FULL,           // Mapa completo com todos os detalhes
        NAVIGATION,     // Apenas dados de navegação
        TRUCK,          // Específico para caminhões
        BASIC          // Mapa básico
    }

    enum class Continent {
        NORTH_AMERICA,
        SOUTH_AMERICA,
        EUROPE,
        ASIA,
        AFRICA,
        OCEANIA
    }

    data class DownloadStatus(
        val progress: Float,     // 0.0 a 1.0
        val bytesDownloaded: Long,
        val totalBytes: Long,
        val estimatedTimeRemaining: Duration,
        val currentSpeed: Long   // bytes por segundo
    )

    // Iniciar download de região
    suspend fun downloadRegion(
        region: MapRegion,
        type: MapType = MapType.FULL
    ): Flow<DownloadStatus> = flow {
        // Verificar espaço disponível
        val availableSpace = storageManager.getAvailableSpace()
        if (availableSpace < region.size) {
            throw InsufficientStorageException(
                required = region.size,
                available = availableSpace
            )
        }

        // Iniciar download
        val downloadJob = mapService.downloadRegion(
            region = region,
            type = type,
            callback = { status -> emit(status) }
        )

        // Processar e validar dados baixados
        val downloadedData = downloadJob.await()
        validateDownloadedData(downloadedData)

        // Armazenar mapa
        storageManager.saveMap(
            region = region,
            data = downloadedData,
            type = type
        )

        // Atualizar metadados
        updateMapMetadata(region, type)
    }

    // Atualizar mapa existente
    suspend fun updateRegion(
        region: MapRegion,
        type: MapType = MapType.FULL
    ): Flow<DownloadStatus> = flow {
        val currentVersion = getMapVersion(region, type)
        val latestVersion = mapService.getLatestVersion(region, type)

        if (currentVersion < latestVersion) {
            val updateJob = mapService.downloadUpdate(
                region = region,
                currentVersion = currentVersion,
                targetVersion = latestVersion,
                callback = { status -> emit(status) }
            )

            val updateData = updateJob.await()
            validateUpdateData(updateData)

            storageManager.applyUpdate(
                region = region,
                updateData = updateData,
                type = type
            )

            updateMapMetadata(region, type)
        }
    }

    // Gerenciar espaço
    suspend fun manageStorage() {
        val installedMaps = storageManager.getInstalledMaps()
        val availableSpace = storageManager.getAvailableSpace()
        val requiredSpace = calculateRequiredSpace()

        if (availableSpace < requiredSpace) {
            // Identificar mapas não utilizados
            val unusedMaps = installedMaps
                .filter { !isMapRecentlyUsed(it) }
                .sortedBy { it.lastUsed }

            // Remover mapas até liberar espaço suficiente
            var spaceToFree = requiredSpace - availableSpace
            unusedMaps.forEach { map ->
                if (spaceToFree > 0) {
                    removeMap(map)
                    spaceToFree -= map.size
                }
            }
        }
    }

    // Obter lista de países disponíveis
    suspend fun getAvailableCountries(): List<Country> {
        return mapService.getAvailableCountries()
            .sortedBy { it.name }
            .filter { it.availableTypes.isNotEmpty() }
    }

    // Obter regiões de um país
    suspend fun getCountryRegions(
        country: Country
    ): List<MapRegion> {
        return mapService.getCountryRegions(country)
            .sortedBy { it.name }
    }

    // Verificar atualizações
    suspend fun checkForUpdates(): List<MapRegion> {
        val installedMaps = storageManager.getInstalledMaps()
        val outdatedMaps = mutableListOf<MapRegion>()

        installedMaps.forEach { map ->
            val currentVersion = getMapVersion(map, map.type)
            val latestVersion = mapService.getLatestVersion(map, map.type)

            if (currentVersion < latestVersion) {
                outdatedMaps.add(map)
            }
        }

        return outdatedMaps
    }

    companion object {
        private val MINIMUM_STORAGE_SPACE = 1024L * 1024L * 1024L // 1GB
        private val UPDATE_CHECK_INTERVAL = Duration.ofDays(7)
        private val MAP_USAGE_THRESHOLD = Duration.ofDays(30)
    }
}

// Exceções
class InsufficientStorageException(
    val required: Long,
    val available: Long
) : Exception(
    "Espaço insuficiente: necessário ${required / 1024 / 1024}MB, " +
    "disponível ${available / 1024 / 1024}MB"
)

// Classes de suporte
data class BoundingBox(
    val north: Double,
    val south: Double,
    val east: Double,
    val west: Double
)

// Interface de armazenamento
interface StorageManager {
    suspend fun getAvailableSpace(): Long
    suspend fun saveMap(region: MapRegion, data: ByteArray, type: MapType)
    suspend fun getInstalledMaps(): List<MapRegion>
    suspend fun removeMap(region: MapRegion)
    suspend fun applyUpdate(region: MapRegion, updateData: ByteArray, type: MapType)
}