// DriverPreferencesML.kt
class DriverPreferencesML(
    private val routeService: RouteService,
    private val driverService: DriverService,
    private val poiService: POIService
) {
    data class DriverProfile(
        val id: String,
        val preferences: PreferenceWeights,
        val routeHistory: List<RouteHistory>,
        val stopPreferences: List<StopPreference>,
        val timePatterns: TimePatterns
    )

    data class PreferenceWeights(
        val tollAvoidance: Float = 0.5f,
        val highwayPreference: Float = 0.5f,
        val restStopFrequency: Float = 0.5f,
        val preferredStopBrands: Map<String, Float> = emptyMap(),
        val timeOfDayPreferences: Map<Int, Float> = emptyMap(),
        val roadTypePreferences: Map<RoadType, Float> = emptyMap()
    )

    data class RouteHistory(
        val routeId: String,
        val startTime: Long,
        val endTime: Long,
        val originalRoute: Route,
        val actualRoute: Route,
        val deviations: List<RouteDeviation>,
        val stops: List<StopEvent>,
        val feedback: RouteFeedback?
    )

    data class StopPreference(
        val poiId: String,
        val visitCount: Int,
        val averageStayTime: Long,
        val rating: Float,
        val timeOfDayDistribution: Map<Int, Int>
    )

    data class TimePatterns(
        val preferredDrivingHours: Set<Int>,
        val preferredRestHours: Set<Int>,
        val averageDrivingDuration: Long,
        val averageRestDuration: Long
    )

    // Aprender com novas rotas
    suspend fun learnFromRoute(routeHistory: RouteHistory) {
        val driverId = routeHistory.routeId.split("_")[0]
        val profile = driverService.getDriverProfile(driverId)

        // Atualizar pesos baseado no comportamento real
        val updatedWeights = updatePreferenceWeights(
            profile.preferences,
            routeHistory
        )

        // Atualizar padrões de tempo
        val updatedTimePatterns = updateTimePatterns(
            profile.timePatterns,
            routeHistory
        )

        // Atualizar preferências de paradas
        val updatedStopPreferences = updateStopPreferences(
            profile.stopPreferences,
            routeHistory.stops
        )

        // Salvar perfil atualizado
        driverService.updateDriverProfile(
            profile.copy(
                preferences = updatedWeights,
                timePatterns = updatedTimePatterns,
                stopPreferences = updatedStopPreferences
            )
        )
    }

    // Atualizar pesos de preferência
    private fun updatePreferenceWeights(
        currentWeights: PreferenceWeights,
        routeHistory: RouteHistory
    ): PreferenceWeights {
        val deviationWeight = 0.2f
        val feedbackWeight = 0.3f
        val historyWeight = 0.5f

        // Analisar desvios da rota sugerida
        val deviationPreferences = analyzeDeviations(routeHistory.deviations)

        // Considerar feedback explícito
        val feedbackPreferences = routeHistory.feedback?.let {
            analyzeFeedback(it)
        } ?: currentWeights

        // Calcular novos pesos
        return PreferenceWeights(
            tollAvoidance = calculateUpdatedWeight(
                current = currentWeights.tollAvoidance,
                deviation = deviationPreferences.tollAvoidance,
                feedback = feedbackPreferences.tollAvoidance,
                deviationWeight = deviationWeight,
                feedbackWeight = feedbackWeight,
                historyWeight = historyWeight
            ),
            highwayPreference = calculateUpdatedWeight(
                current = currentWeights.highwayPreference,
                deviation = deviationPreferences.highwayPreference,
                feedback = feedbackPreferences.highwayPreference,
                deviationWeight = deviationWeight,
                feedbackWeight = feedbackWeight,
                historyWeight = historyWeight
            ),
            restStopFrequency = calculateUpdatedWeight(
                current = currentWeights.restStopFrequency,
                deviation = deviationPreferences.restStopFrequency,
                feedback = feedbackPreferences.restStopFrequency,
                deviationWeight = deviationWeight,
                feedbackWeight = feedbackWeight,
                historyWeight = historyWeight
            ),
            preferredStopBrands = updateStopBrandPreferences(
                currentWeights.preferredStopBrands,
                routeHistory.stops
            ),
            timeOfDayPreferences = updateTimePreferences(
                currentWeights.timeOfDayPreferences,
                routeHistory
            ),
            roadTypePreferences = updateRoadTypePreferences(
                currentWeights.roadTypePreferences,
                routeHistory
            )
        )
    }

    // Gerar rota otimizada baseada no perfil
    suspend fun generateOptimizedRoute(
        origin: Location,
        destination: Location,
        driverId: String,
        constraints: RouteConstraints
    ): Route {
        val profile = driverService.getDriverProfile(driverId)
        
        // Ajustar parâmetros da rota baseado nas preferências
        val routeParams = RouteParameters(
            // Evitar pedágios baseado na preferência aprendida
            tollPreference = when {
                profile.preferences.tollAvoidance > 0.7f -> TollPreference.AVOID
                profile.preferences.tollAvoidance < 0.3f -> TollPreference.PREFER
                else -> TollPreference.NEUTRAL
            },
            
            // Preferência por tipo de estrada
            roadPreference = profile.preferences.roadTypePreferences
                .mapValues { (_, weight) -> 
                    when {
                        weight > 0.7f -> RoadPreference.PREFER
                        weight < 0.3f -> RoadPreference.AVOID
                        else -> RoadPreference.NEUTRAL
                    }
                },
            
            // Incluir paradas recomendadas
            recommendedStops = generateRecommendedStops(
                origin = origin,
                destination = destination,
                profile = profile,
                constraints = constraints
            ),
            
            // Ajustar horários baseado nos padrões
            timePreferences = generateTimePreferences(profile.timePatterns)
        )

        return routeService.calculateRoute(
            origin = origin,
            destination = destination,
            params = routeParams,
            constraints = constraints
        )
    }

    // Gerar paradas recomendadas
    private suspend fun generateRecommendedStops(
        origin: Location,
        destination: Location,
        profile: DriverProfile,
        constraints: RouteConstraints
    ): List<RecommendedStop> {
        val totalDistance = calculateDistance(origin, destination)
        val estimatedDuration = estimateDuration(totalDistance, constraints)
        
        // Calcular número ideal de paradas
        val recommendedStops = calculateRecommendedStops(
            duration = estimatedDuration,
            avgDrivingTime = profile.timePatterns.averageDrivingDuration
        )

        // Encontrar melhores locais para parada
        return findOptimalStops(
            origin = origin,
            destination = destination,
            numberOfStops = recommendedStops,
            preferences = profile.preferences,
            stopHistory = profile.stopPreferences
        )
    }

    companion object {
        private const val LEARNING_RATE = 0.2f
        private const val HISTORY_WINDOW_DAYS = 30
        private const val MIN_CONFIDENCE_THRESHOLD = 0.6f
    }
}